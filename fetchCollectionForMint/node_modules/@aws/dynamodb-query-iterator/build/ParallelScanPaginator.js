"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mergeConsumedCapacities_1 = require("./mergeConsumedCapacities");
var ScanPaginator_1 = require("./ScanPaginator");
if (Symbol && !Symbol.asyncIterator) {
    Symbol.asyncIterator = Symbol.for("__@@asyncIterator__");
}
var ParallelScanPaginator = /** @class */ (function () {
    function ParallelScanPaginator(client, input, scanState) {
        if (scanState === void 0) { scanState = nullScanState(input.TotalSegments); }
        this.pending = [];
        this.lastResolved = Promise.resolve();
        var TotalSegments = input.TotalSegments;
        if (scanState.length !== TotalSegments) {
            throw new Error("Parallel scan state must have a length equal to the number of "
                + ("scan segments. Expected an array of " + TotalSegments + " but")
                + ("received an array with " + scanState.length + " elements."));
        }
        this.iterators = new Array(TotalSegments);
        for (var i = 0; i < TotalSegments; i++) {
            var iterator = new ScanPaginator_1.ScanPaginator(client, tslib_1.__assign({}, input, { Segment: i, ExclusiveStartKey: scanState[i].LastEvaluatedKey }));
            this.iterators[i] = iterator;
            // If the segment has not been initialized or a pagination token has
            // been received, request the next page.
            if (!scanState[i].initialized || scanState[i].LastEvaluatedKey) {
                this.refillPending(iterator, i);
            }
        }
        this._scanState = tslib_1.__spread(scanState);
    }
    /**
     * @inheritDoc
     */
    ParallelScanPaginator.prototype[Symbol.asyncIterator] = function () {
        return this;
    };
    Object.defineProperty(ParallelScanPaginator.prototype, "consumedCapacity", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this.iterators.reduce(function (merged, paginator) { return mergeConsumedCapacities_1.mergeConsumedCapacities(merged, paginator.consumedCapacity); }, undefined);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParallelScanPaginator.prototype, "count", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this.iterators.reduce(function (sum, paginator) { return sum + paginator.count; }, 0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ParallelScanPaginator.prototype.next = function () {
        var _this = this;
        this.lastResolved = this.lastResolved.then(function () { return _this.getNext(); });
        return this.lastResolved;
    };
    ParallelScanPaginator.prototype.getNext = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, iterator, _b, value, done, segment, i;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.pending.length === 0) {
                            return [2 /*return*/, doneSigil()];
                        }
                        return [4 /*yield*/, Promise.race(this.pending.map(function (pending) { return pending.result; }))];
                    case 1:
                        _a = _c.sent(), iterator = _a.iterator, _b = _a.result, value = _b.value, done = _b.done, segment = _a.segment;
                        // Update the scan state for this segment. This will either be the last
                        // evaluated key (for an unfinished segment) or undefined (for a
                        // completed segment).
                        this._scanState[segment] = {
                            initialized: true,
                            LastEvaluatedKey: value && value.LastEvaluatedKey,
                        };
                        // Remove the result from the pending set.
                        for (i = this.pending.length - 1; i >= 0; i--) {
                            if (this.pending[i].iterator === iterator) {
                                this.pending.splice(i, 1);
                            }
                        }
                        // If the iterator is not finished, add its next result to the pending
                        // set.
                        if (!done) {
                            this.refillPending(iterator, segment);
                            return [2 /*return*/, { value: value, done: done }];
                        }
                        else {
                            // If a segment has finished but there are still outstanding
                            // requests, recur. A done sigil will be returned when the pending
                            // queue is empty.
                            return [2 /*return*/, this.getNext()];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @inheritDoc
     */
    ParallelScanPaginator.prototype.return = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.pending.length = 0;
                return [2 /*return*/, Promise.all(this.iterators.map(function (iterator) { return iterator.return(); }))
                        .then(doneSigil)];
            });
        });
    };
    Object.defineProperty(ParallelScanPaginator.prototype, "scannedCount", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this.iterators.reduce(function (sum, paginator) { return sum + paginator.scannedCount; }, 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParallelScanPaginator.prototype, "scanState", {
        /**
         * A snapshot of the current state of a parallel scan. May be used to resume
         * a parallel scan with a separate paginator.
         */
        get: function () {
            return tslib_1.__spread(this._scanState);
        },
        enumerable: true,
        configurable: true
    });
    ParallelScanPaginator.prototype.refillPending = function (iterator, segment) {
        // Use .push to reorder segments within the array of pending results.
        // Promise.race will iterate over the array of pending results until a
        // resolved promise is found and therefore will naturally favor promises
        // towards the head of the queue. Removing resolved segments and sending
        // them to the back of the line will keep this implementation detail
        // from creating hot and cold scan segments.
        this.pending.push({
            iterator: iterator,
            result: iterator.next()
                .then(function (result) { return ({ iterator: iterator, result: result, segment: segment }); }),
        });
    };
    return ParallelScanPaginator;
}());
exports.ParallelScanPaginator = ParallelScanPaginator;
function doneSigil() {
    return { done: true };
}
/**
 * `Array.prototype.fill` is not available in IE, so a loop is used instead
 */
function nullScanState(length) {
    var target = new Array(length);
    for (var i = 0; i < length; i++) {
        target[i] = { initialized: false };
    }
    return target;
}
//# sourceMappingURL=ParallelScanPaginator.js.map