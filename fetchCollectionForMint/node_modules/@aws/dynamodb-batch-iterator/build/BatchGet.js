"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var BatchOperation_1 = require("./BatchOperation");
exports.MAX_READ_BATCH_SIZE = 100;
/**
 * Retrieves items from DynamoDB in batches of 100 or fewer via one or more
 * BatchGetItem operations. The items may be from any number of tables.
 *
 * This method will automatically retry any get requests returned by DynamoDB as
 * unprocessed. Exponential backoff on unprocessed items is employed on a
 * per-table basis.
 */
var BatchGet = /** @class */ (function (_super) {
    tslib_1.__extends(BatchGet, _super);
    /**
     * @param client    The AWS SDK client with which to communicate with
     *                  DynamoDB.
     * @param items     A synchronous or asynchronous iterable of tuples
     *                  describing the reads to execute. The first member of the
     *                  tuple should be the name of the table from which to
     *                  read, and the second should be the marshalled key.
     * @param options   Additional options to apply to the operations executed.
     */
    function BatchGet(client, items, _a) {
        var _b = _a === void 0 ? {} : _a, ConsistentRead = _b.ConsistentRead, _c = _b.PerTableOptions, PerTableOptions = _c === void 0 ? {} : _c;
        var _this = _super.call(this, client, items) || this;
        _this.batchSize = exports.MAX_READ_BATCH_SIZE;
        _this.consistentRead = ConsistentRead;
        _this.options = PerTableOptions;
        return _this;
    }
    BatchGet.prototype.doBatchRequest = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1, _a, e_2, _b, e_3, _c, operationInput, batchSize, _d, tableName, item, _e, projection, consistentRead, attributeNames, _f, _g, Responses, _h, UnprocessedKeys, unprocessedTables, _j, _k, table, _l, _m, table, tableData, _o, _p, item;
            return tslib_1.__generator(this, function (_q) {
                switch (_q.label) {
                    case 0:
                        operationInput = { RequestItems: {} };
                        batchSize = 0;
                        while (this.toSend.length > 0) {
                            _d = tslib_1.__read(this.toSend.shift(), 2), tableName = _d[0], item = _d[1];
                            if (operationInput.RequestItems[tableName] === undefined) {
                                _e = this.state[tableName], projection = _e.projection, consistentRead = _e.consistentRead, attributeNames = _e.attributeNames;
                                operationInput.RequestItems[tableName] = {
                                    Keys: [],
                                    ConsistentRead: consistentRead,
                                    ProjectionExpression: projection,
                                    ExpressionAttributeNames: attributeNames,
                                };
                            }
                            operationInput.RequestItems[tableName].Keys.push(item);
                            if (++batchSize === this.batchSize) {
                                break;
                            }
                        }
                        return [4 /*yield*/, this.client.batchGetItem(operationInput).promise()];
                    case 1:
                        _f = _q.sent(), _g = _f.Responses, Responses = _g === void 0 ? {} : _g, _h = _f.UnprocessedKeys, UnprocessedKeys = _h === void 0 ? {} : _h;
                        unprocessedTables = new Set();
                        try {
                            for (_j = tslib_1.__values(Object.keys(UnprocessedKeys)), _k = _j.next(); !_k.done; _k = _j.next()) {
                                table = _k.value;
                                unprocessedTables.add(table);
                                this.handleThrottled(table, UnprocessedKeys[table].Keys);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_k && !_k.done && (_a = _j.return)) _a.call(_j);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        this.movePendingToThrottled(unprocessedTables);
                        try {
                            for (_l = tslib_1.__values(Object.keys(Responses)), _m = _l.next(); !_m.done; _m = _l.next()) {
                                table = _m.value;
                                tableData = this.state[table];
                                tableData.backoffFactor = Math.max(0, tableData.backoffFactor - 1);
                                try {
                                    for (_o = tslib_1.__values(Responses[table]), _p = _o.next(); !_p.done; _p = _o.next()) {
                                        item = _p.value;
                                        this.pending.push([table, item]);
                                    }
                                }
                                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                                finally {
                                    try {
                                        if (_p && !_p.done && (_c = _o.return)) _c.call(_o);
                                    }
                                    finally { if (e_3) throw e_3.error; }
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_m && !_m.done && (_b = _l.return)) _b.call(_l);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    BatchGet.prototype.getInitialTableState = function (tableName) {
        var _a = this.options[tableName] || {}, ExpressionAttributeNames = _a.ExpressionAttributeNames, ProjectionExpression = _a.ProjectionExpression, _b = _a.ConsistentRead, ConsistentRead = _b === void 0 ? this.consistentRead : _b;
        return tslib_1.__assign({}, _super.prototype.getInitialTableState.call(this, tableName), { attributeNames: ExpressionAttributeNames, projection: ProjectionExpression, consistentRead: ConsistentRead });
    };
    return BatchGet;
}(BatchOperation_1.BatchOperation));
exports.BatchGet = BatchGet;
//# sourceMappingURL=BatchGet.js.map