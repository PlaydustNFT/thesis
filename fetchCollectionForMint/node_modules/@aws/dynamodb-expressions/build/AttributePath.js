"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ATTRIBUTE_PATH_TAG = 'AmazonDynamoDbAttributePath';
var EXPECTED_TAG = "[object " + ATTRIBUTE_PATH_TAG + "]";
/**
 * The path to an attribute of a DynamoDB item or to a property
 * or member thereof. Supports map property access (`map.property`)
 * and list member access (`list[1]`).
 *
 * Control characters that are part of the property identifier may be
 * used when escaped with a backslash (`\`) character.
 */
var AttributePath = /** @class */ (function () {
    function AttributePath(path) {
        this[Symbol.toStringTag] = ATTRIBUTE_PATH_TAG;
        if (typeof path === 'string') {
            this.elements = parsePath(path);
        }
        else {
            this.elements = tslib_1.__spread(path);
        }
    }
    /**
     * Determine if the provided value is an AttributePath object.
     * Compatible with AttributePath objects generated in other iframes
     * or Node VMs.
     */
    AttributePath.isAttributePath = function (arg) {
        return arg instanceof AttributePath
            || Object.prototype.toString.call(arg) === EXPECTED_TAG;
    };
    return AttributePath;
}());
exports.AttributePath = AttributePath;
var LEFT_BRACKET = '[';
var RIGHT_BRACKET = ']';
var PATH_DELIMITER = '.';
var ESCAPE_CHARACTER = '\\';
function parsePath(path) {
    var elements = [];
    var state = 1001 /* identifier */;
    var collected = '';
    for (var iter = path[Symbol.iterator](), curr = iter.next(), peek = iter.next(); curr.done === false; curr = peek, peek = iter.next()) {
        if (state === 1001 /* identifier */) {
            switch (curr.value) {
                case LEFT_BRACKET:
                    state = 1002 /* listIndex */;
                // fallthrough
                case PATH_DELIMITER:
                    if (collected === '') {
                        throw new Error("Invalid control character encountered in path: " + path);
                    }
                    elements.push({ type: 'AttributeName', name: collected });
                    collected = '';
                    break;
                case ESCAPE_CHARACTER:
                    if (peek.value === PATH_DELIMITER ||
                        peek.value === LEFT_BRACKET ||
                        peek.value === ESCAPE_CHARACTER) {
                        curr = peek;
                        peek = iter.next();
                    }
                // fallthrough
                default:
                    collected += curr.value;
            }
        }
        else if (state === 1002 /* listIndex */) {
            switch (curr.value) {
                case RIGHT_BRACKET:
                    var intVal = parseInt(collected);
                    if (!isFinite(intVal)) {
                        throw new Error("Invalid array index (" + collected + ") encountered in path: " + path);
                    }
                    elements.push({ type: 'ListIndex', index: intVal });
                    collected = '';
                    state = 1000 /* controlCharacter */;
                    break;
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    collected += curr.value;
                    break;
                default:
                    throw new Error("Invalid array index character (" + curr.value + ") encountered in path: " + path);
            }
        }
        else {
            switch (curr.value) {
                case LEFT_BRACKET:
                    state = 1002 /* listIndex */;
                    break;
                case PATH_DELIMITER:
                    state = 1001 /* identifier */;
                    break;
                default:
                    throw new Error("Bare identifier encountered between list index accesses in path: " + path);
            }
        }
    }
    if (collected.length > 0) {
        elements.push({ type: 'AttributeName', name: collected });
    }
    return elements;
}
//# sourceMappingURL=AttributePath.js.map