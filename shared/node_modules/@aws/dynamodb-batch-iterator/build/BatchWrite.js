"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var BatchOperation_1 = require("./BatchOperation");
var itemIdentifier_1 = require("./itemIdentifier");
exports.MAX_WRITE_BATCH_SIZE = 25;
/**
 * Puts or deletes items from DynamoDB in batches of 25 or fewer via one or more
 * BatchWriteItem operations. The items may belong to any number of tables.
 *
 * The iterable of writes to perform may be synchronous or asynchronous and is
 * expected to yield tuples describing the writes to be performed. The first
 * member should be the table name, and the second should be {WriteRequest}
 * object that defines either a put request or a delete request.
 *
 * This method will automatically retry any write requests returned by DynamoDB
 * as unprocessed. Exponential backoff on unprocessed items is employed on a
 * per-table basis.
 */
var BatchWrite = /** @class */ (function (_super) {
    tslib_1.__extends(BatchWrite, _super);
    function BatchWrite() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.batchSize = exports.MAX_WRITE_BATCH_SIZE;
        return _this;
    }
    BatchWrite.prototype.doBatchRequest = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1, _a, e_2, _b, e_3, _c, e_4, _d, inFlight, operationInput, batchSize, _e, tableName, marshalled, _f, UnprocessedItems, unprocessedTables, _g, _h, table, unprocessed, _j, _k, item, identifier, i, _l, tableName, attributes, processedTables, inFlight_1, inFlight_1_1, _m, tableName, marshalled, processedTables_1, processedTables_1_1, tableName;
            return tslib_1.__generator(this, function (_o) {
                switch (_o.label) {
                    case 0:
                        inFlight = [];
                        operationInput = { RequestItems: {} };
                        batchSize = 0;
                        while (this.toSend.length > 0) {
                            _e = tslib_1.__read(this.toSend.shift(), 2), tableName = _e[0], marshalled = _e[1];
                            inFlight.push([tableName, marshalled]);
                            if (operationInput.RequestItems[tableName] === undefined) {
                                operationInput.RequestItems[tableName] = [];
                            }
                            operationInput.RequestItems[tableName].push(marshalled);
                            if (++batchSize === this.batchSize) {
                                break;
                            }
                        }
                        return [4 /*yield*/, this.client.batchWriteItem(operationInput).promise()];
                    case 1:
                        _f = (_o.sent()).UnprocessedItems, UnprocessedItems = _f === void 0 ? {} : _f;
                        unprocessedTables = new Set();
                        try {
                            for (_g = tslib_1.__values(Object.keys(UnprocessedItems)), _h = _g.next(); !_h.done; _h = _g.next()) {
                                table = _h.value;
                                unprocessedTables.add(table);
                                unprocessed = [];
                                try {
                                    for (_j = tslib_1.__values(UnprocessedItems[table]), _k = _j.next(); !_k.done; _k = _j.next()) {
                                        item = _k.value;
                                        if (item.DeleteRequest || item.PutRequest) {
                                            unprocessed.push(item);
                                            identifier = itemIdentifier_1.itemIdentifier(table, item);
                                            for (i = inFlight.length - 1; i >= 0; i--) {
                                                _l = tslib_1.__read(inFlight[i], 2), tableName = _l[0], attributes = _l[1];
                                                if (tableName === table &&
                                                    itemIdentifier_1.itemIdentifier(tableName, attributes) === identifier) {
                                                    inFlight.splice(i, 1);
                                                }
                                            }
                                        }
                                    }
                                }
                                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                finally {
                                    try {
                                        if (_k && !_k.done && (_b = _j.return)) _b.call(_j);
                                    }
                                    finally { if (e_2) throw e_2.error; }
                                }
                                this.handleThrottled(table, unprocessed);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        this.movePendingToThrottled(unprocessedTables);
                        processedTables = new Set();
                        try {
                            for (inFlight_1 = tslib_1.__values(inFlight), inFlight_1_1 = inFlight_1.next(); !inFlight_1_1.done; inFlight_1_1 = inFlight_1.next()) {
                                _m = tslib_1.__read(inFlight_1_1.value, 2), tableName = _m[0], marshalled = _m[1];
                                processedTables.add(tableName);
                                this.pending.push([tableName, marshalled]);
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (inFlight_1_1 && !inFlight_1_1.done && (_c = inFlight_1.return)) _c.call(inFlight_1);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                        try {
                            for (processedTables_1 = tslib_1.__values(processedTables), processedTables_1_1 = processedTables_1.next(); !processedTables_1_1.done; processedTables_1_1 = processedTables_1.next()) {
                                tableName = processedTables_1_1.value;
                                this.state[tableName].backoffFactor =
                                    Math.max(0, this.state[tableName].backoffFactor - 1);
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (processedTables_1_1 && !processedTables_1_1.done && (_d = processedTables_1.return)) _d.call(processedTables_1);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    return BatchWrite;
}(BatchOperation_1.BatchOperation));
exports.BatchWrite = BatchWrite;
//# sourceMappingURL=BatchWrite.js.map