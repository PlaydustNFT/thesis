"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
if (Symbol && !Symbol.asyncIterator) {
    Symbol.asyncIterator = Symbol.for("__@@asyncIterator__");
}
var BatchOperation = /** @class */ (function () {
    /**
     * @param client    The AWS SDK client with which to communicate with
     *                  DynamoDB.
     * @param items     A synchronous or asynchronous iterable of tuples
     *                  describing the operations to execute. The first member
     *                  of the tuple should be the name of the table targeted by
     *                  the operation.
     */
    function BatchOperation(client, items) {
        this.client = client;
        /**
         * Items that have been retrieved and are ready to be returned.
         */
        this.pending = [];
        /**
         * A mapping of table names to table-specific operation state (e.g., the
         * number of throttling events experienced, etc.)
         */
        this.state = {};
        /**
         * Input elements that are prepared for immediate dispatch
         */
        this.toSend = [];
        this.throttled = new Set();
        this.sourceDone = false;
        if (isIterable(items)) {
            this.iterator = items[Symbol.iterator]();
        }
        else {
            this.iterator = items[Symbol.asyncIterator]();
        }
        this.sourceNext = this.iterator.next();
    }
    BatchOperation.prototype.next = function () {
        var _this = this;
        if (this.lastResolved) {
            this.lastResolved = this.lastResolved.then(function () { return _this.getNext(); });
        }
        else {
            this.lastResolved = this.getNext();
        }
        return this.lastResolved;
    };
    BatchOperation.prototype[Symbol.asyncIterator] = function () {
        return this;
    };
    /**
     * Create and return the initial state object for a given DynamoDB table.
     *
     * @param tableName The name of the table whose initial state should be
     *                  returned.
     */
    BatchOperation.prototype.getInitialTableState = function (tableName) {
        return {
            backoffFactor: 0,
            name: tableName,
        };
    };
    /**
     * Accept an array of unprocessed items belonging to a single table and
     * re-enqueue it for submission, making sure the appropriate level of
     * backoff is applied to future operations on the same table.
     *
     * @param tableName     The table to which the unprocessed elements belong.
     * @param unprocessed   Elements returned by DynamoDB as not yet processed.
     *                      The elements should not be unmarshalled, but they
     *                      should be reverted to the form used for elements
     *                      that have not yet been sent.
     */
    BatchOperation.prototype.handleThrottled = function (tableName, unprocessed) {
        var tableState = this.state[tableName];
        tableState.backoffFactor++;
        if (tableState.tableThrottling) {
            this.throttled.delete(tableState.tableThrottling.backoffWaiter);
            unprocessed.unshift.apply(unprocessed, tslib_1.__spread(tableState.tableThrottling.unprocessed));
        }
        tableState.tableThrottling = {
            unprocessed: unprocessed,
            backoffWaiter: new Promise(function (resolve) {
                setTimeout(resolve, exponentialBackoff(tableState.backoffFactor), tableState);
            })
        };
        this.throttled.add(tableState.tableThrottling.backoffWaiter);
    };
    /**
     * Iterate over all pending writes and move those targeting throttled tables
     * into the throttled queue.
     *
     * @param unprocessedTables     A set of tables for which some items were
     *                              returned without being processed.
     */
    BatchOperation.prototype.movePendingToThrottled = function (unprocessedTables) {
        for (var i = this.toSend.length - 1; i > -1; i--) {
            var _a = tslib_1.__read(this.toSend[i], 2), table = _a[0], attributes = _a[1];
            if (unprocessedTables.has(table)) {
                this.state[table]
                    .tableThrottling.unprocessed.push(attributes);
                this.toSend.splice(i, 1);
            }
        }
    };
    BatchOperation.prototype.addToSendQueue = function (_a) {
        var _b = tslib_1.__read(_a, 2), tableName = _b[0], attributes = _b[1];
        if (!this.state[tableName]) {
            this.state[tableName] = this.getInitialTableState(tableName);
        }
        var tableState = this.state[tableName];
        if (tableState.tableThrottling) {
            tableState.tableThrottling.unprocessed.push(attributes);
        }
        else {
            this.toSend.push([tableName, attributes]);
        }
    };
    BatchOperation.prototype.enqueueThrottled = function (table) {
        var _a;
        var _b = table.tableThrottling, backoffWaiter = _b.backoffWaiter, unprocessed = _b.unprocessed;
        if (unprocessed.length > 0) {
            (_a = this.toSend).push.apply(_a, tslib_1.__spread(unprocessed.map(function (attr) { return [table.name, attr]; })));
        }
        this.throttled.delete(backoffWaiter);
        delete table.tableThrottling;
    };
    BatchOperation.prototype.getNext = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.sourceDone &&
                            this.pending.length === 0 &&
                            this.toSend.length === 0 &&
                            this.throttled.size === 0) {
                            return [2 /*return*/, { done: true }];
                        }
                        if (this.pending.length > 0) {
                            return [2 /*return*/, {
                                    done: false,
                                    value: this.pending.shift()
                                }];
                        }
                        return [4 /*yield*/, this.refillPending()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.getNext()];
                }
            });
        });
    };
    BatchOperation.prototype.refillPending = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var toProcess, _a, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!(!this.sourceDone &&
                            this.toSend.length < this.batchSize)) return [3 /*break*/, 4];
                        if (!isIteratorResult(this.sourceNext)) return [3 /*break*/, 1];
                        _a = this.sourceNext;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, Promise.race([
                            this.sourceNext,
                            Promise.race(this.throttled)
                        ])];
                    case 2:
                        _a = _c.sent();
                        _c.label = 3;
                    case 3:
                        toProcess = _a;
                        if (isIteratorResult(toProcess)) {
                            this.sourceDone = toProcess.done;
                            if (!this.sourceDone) {
                                this.addToSendQueue(toProcess.value);
                                this.sourceNext = this.iterator.next();
                            }
                        }
                        else {
                            this.enqueueThrottled(toProcess);
                        }
                        return [3 /*break*/, 0];
                    case 4:
                        if (!(this.toSend.length < this.batchSize && this.throttled.size > 0)) return [3 /*break*/, 6];
                        _b = this.enqueueThrottled;
                        return [4 /*yield*/, Promise.race(this.throttled)];
                    case 5:
                        _b.apply(this, [_c.sent()]);
                        return [3 /*break*/, 4];
                    case 6:
                        if (!(this.toSend.length > 0)) return [3 /*break*/, 8];
                        return [4 /*yield*/, this.doBatchRequest()];
                    case 7:
                        _c.sent();
                        _c.label = 8;
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    return BatchOperation;
}());
exports.BatchOperation = BatchOperation;
function exponentialBackoff(attempts) {
    return Math.floor(Math.random() * Math.pow(2, attempts));
}
function isIterable(arg) {
    return Boolean(arg) && typeof arg[Symbol.iterator] === 'function';
}
function isIteratorResult(arg) {
    return Boolean(arg) && typeof arg.done === 'boolean';
}
//# sourceMappingURL=BatchOperation.js.map