"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var toSchemaName_1 = require("./toSchemaName");
var dynamodb_expressions_1 = require("@aws/dynamodb-expressions");
/**
 * Serialize a condition expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
function marshallConditionExpression(expression, schema, attributes) {
    if (attributes === void 0) { attributes = new dynamodb_expressions_1.ExpressionAttributes; }
    var serialized = dynamodb_expressions_1.serializeConditionExpression(normalizeConditionExpression(expression, schema), attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
exports.marshallConditionExpression = marshallConditionExpression;
/**
 * Serialize a function expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
function marshallFunctionExpression(expression, schema, attributes) {
    if (attributes === void 0) { attributes = new dynamodb_expressions_1.ExpressionAttributes; }
    var serialized = normalizeFunctionExpression(expression, schema)
        .serialize(attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
exports.marshallFunctionExpression = marshallFunctionExpression;
/**
 * Serialize a mathematical expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
function marshallMathematicalExpression(expression, schema, attributes) {
    if (attributes === void 0) { attributes = new dynamodb_expressions_1.ExpressionAttributes; }
    var serialized = normalizeMathematicalExpression(expression, schema)
        .serialize(attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
exports.marshallMathematicalExpression = marshallMathematicalExpression;
/**
 * Serialize a projection expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
function marshallProjectionExpression(expression, schema, attributes) {
    if (attributes === void 0) { attributes = new dynamodb_expressions_1.ExpressionAttributes; }
    var serialized = dynamodb_expressions_1.serializeProjectionExpression(expression.map(function (el) { return toSchemaName_1.toSchemaName(el, schema); }), attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
exports.marshallProjectionExpression = marshallProjectionExpression;
/**
 * Serialize an update expression, substituting any property names for the
 * corresponding attribute names in the provided schema.
 *
 * @param expression The expression object to marshall.
 * @param schema The schema of the table to which the expression pertains.
 * @param attributes An optional ExpressionAttributes object to synchronize
 *                      substitutions across multiple expressions.
 */
function marshallUpdateExpression(expression, schema, attributes) {
    if (attributes === void 0) { attributes = new dynamodb_expressions_1.ExpressionAttributes; }
    var serialized = normalizeUpdateExpression(expression, schema)
        .serialize(attributes);
    return {
        expression: serialized,
        ExpressionAttributeNames: attributes.names,
        ExpressionAttributeValues: attributes.values,
    };
}
exports.marshallUpdateExpression = marshallUpdateExpression;
function normalizeConditionExpression(expression, schema) {
    if (dynamodb_expressions_1.FunctionExpression.isFunctionExpression(expression)) {
        return normalizeFunctionExpression(expression, schema);
    }
    switch (expression.type) {
        case 'Equals':
        case 'NotEquals':
        case 'LessThan':
        case 'LessThanOrEqualTo':
        case 'GreaterThan':
        case 'GreaterThanOrEqualTo':
            return tslib_1.__assign({}, expression, { subject: toSchemaName_1.toSchemaName(expression.subject, schema), object: normalizeIfPath(expression.object, schema) });
        case 'Function':
            switch (expression.name) {
                case 'attribute_exists':
                case 'attribute_not_exists':
                    return tslib_1.__assign({}, expression, { subject: toSchemaName_1.toSchemaName(expression.subject, schema) });
                case 'attribute_type':
                case 'begins_with':
                case 'contains':
                    return tslib_1.__assign({}, expression, { subject: toSchemaName_1.toSchemaName(expression.subject, schema) });
            }
        case 'Between':
            return tslib_1.__assign({}, expression, { subject: toSchemaName_1.toSchemaName(expression.subject, schema), lowerBound: normalizeIfPath(expression.lowerBound, schema), upperBound: normalizeIfPath(expression.upperBound, schema) });
        case 'Membership':
            return tslib_1.__assign({}, expression, { subject: toSchemaName_1.toSchemaName(expression.subject, schema), values: expression.values.map(function (arg) { return normalizeIfPath(arg, schema); }) });
        case 'Not':
            return tslib_1.__assign({}, expression, { condition: normalizeConditionExpression(expression.condition, schema) });
        case 'And':
        case 'Or':
            return tslib_1.__assign({}, expression, { conditions: expression.conditions.map(function (condition) {
                    return normalizeConditionExpression(condition, schema);
                }) });
    }
}
function normalizeFunctionExpression(expression, schema) {
    return new (dynamodb_expressions_1.FunctionExpression.bind.apply(dynamodb_expressions_1.FunctionExpression, tslib_1.__spread([void 0, expression.name], expression.args.map(function (arg) { return normalizeIfPath(arg, schema); }))))();
}
function normalizeMathematicalExpression(expression, schema) {
    return new dynamodb_expressions_1.MathematicalExpression(dynamodb_expressions_1.AttributePath.isAttributePath(expression.lhs) || typeof expression.lhs === 'string'
        ? toSchemaName_1.toSchemaName(expression.lhs, schema)
        : expression.lhs, expression.operator, dynamodb_expressions_1.AttributePath.isAttributePath(expression.rhs) || typeof expression.rhs === 'string'
        ? toSchemaName_1.toSchemaName(expression.rhs, schema)
        : expression.rhs);
}
var mapsToTransform = [
    ['toAdd', 'add'],
    ['toDelete', 'delete'],
    ['toSet', 'set'],
];
function normalizeUpdateExpression(expression, schema) {
    var e_1, _a, e_2, _b;
    var normalized = new dynamodb_expressions_1.UpdateExpression;
    try {
        for (var mapsToTransform_1 = tslib_1.__values(mapsToTransform), mapsToTransform_1_1 = mapsToTransform_1.next(); !mapsToTransform_1_1.done; mapsToTransform_1_1 = mapsToTransform_1.next()) {
            var _c = tslib_1.__read(mapsToTransform_1_1.value, 2), dataSet = _c[0], exprMethod = _c[1];
            try {
                for (var _d = tslib_1.__values(expression[dataSet]), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var _f = tslib_1.__read(_e.value, 2), path = _f[0], value = _f[1];
                    normalized[exprMethod](toSchemaName_1.toSchemaName(path, schema), value);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (mapsToTransform_1_1 && !mapsToTransform_1_1.done && (_a = mapsToTransform_1.return)) _a.call(mapsToTransform_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    expression.toRemove.forEach(function (el) { return normalized.remove(toSchemaName_1.toSchemaName(el, schema)); });
    return normalized;
}
function normalizeIfPath(path, schema) {
    if (dynamodb_expressions_1.AttributePath.isAttributePath(path)) {
        return toSchemaName_1.toSchemaName(path, schema);
    }
    return path;
}
//# sourceMappingURL=marshallExpression.js.map