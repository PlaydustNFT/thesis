"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * @internal
 */
function mergeConsumedCapacities(a, b) {
    if (a || b) {
        a = a || {};
        b = b || {};
        if ((a.TableName && b.TableName) && a.TableName !== b.TableName) {
            throw new Error('Consumed capacity reports may only be merged if they describe the same table');
        }
        return {
            TableName: a.TableName || b.TableName,
            CapacityUnits: (a.CapacityUnits || 0) + (b.CapacityUnits || 0),
            Table: mergeCapacities(a.Table, b.Table),
            LocalSecondaryIndexes: mergeCapacityMaps(a.LocalSecondaryIndexes, b.LocalSecondaryIndexes),
            GlobalSecondaryIndexes: mergeCapacityMaps(a.GlobalSecondaryIndexes, b.GlobalSecondaryIndexes),
        };
    }
}
exports.mergeConsumedCapacities = mergeConsumedCapacities;
function mergeCapacities(a, b) {
    if (a || b) {
        return {
            CapacityUnits: ((a && a.CapacityUnits) || 0) +
                ((b && b.CapacityUnits) || 0),
        };
    }
}
function mergeCapacityMaps(a, b) {
    var e_1, _a, e_2, _b, e_3, _c;
    if (a || b) {
        var out = {};
        a = a || {};
        b = b || {};
        var keys = new Set();
        try {
            for (var _d = tslib_1.__values([a, b]), _e = _d.next(); !_e.done; _e = _d.next()) {
                var map = _e.value;
                try {
                    for (var _f = tslib_1.__values(Object.keys(map)), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var indexName = _g.value;
                        keys.add(indexName);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var keys_1 = tslib_1.__values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                var key = keys_1_1.value;
                out[key] = mergeCapacities(a[key], b[key]);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (keys_1_1 && !keys_1_1.done && (_c = keys_1.return)) _c.call(keys_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return out;
    }
}
//# sourceMappingURL=mergeConsumedCapacities.js.map