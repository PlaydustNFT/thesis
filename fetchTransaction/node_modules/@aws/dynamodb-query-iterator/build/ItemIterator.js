"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
if (Symbol && !Symbol.asyncIterator) {
    Symbol.asyncIterator = Symbol.for("__@@asyncIterator__");
}
var ItemIterator = /** @class */ (function () {
    function ItemIterator(paginator) {
        this.paginator = paginator;
        this._iteratedCount = 0;
        this.lastResolved = Promise.resolve();
        this.pending = [];
    }
    /**
     * @inheritDoc
     */
    ItemIterator.prototype[Symbol.asyncIterator] = function () {
        return this;
    };
    Object.defineProperty(ItemIterator.prototype, "consumedCapacity", {
        /**
         * The capacity units consumed by the Scan operation. The data returned
         * includes the total provisioned throughput consumed, along with statistics
         * for the table and any indexes involved in the operation. ConsumedCapacity
         * is only returned if the ReturnConsumedCapacity parameter was specified.
         */
        get: function () {
            return this.paginator.consumedCapacity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ItemIterator.prototype, "count", {
        /**
         * The number of items that have been iterated over.
         */
        get: function () {
            return this._iteratedCount;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ItemIterator.prototype.next = function () {
        var _this = this;
        this.lastResolved = this.lastResolved.then(function () { return _this.getNext(); });
        return this.lastResolved;
    };
    /**
     * Detaches the underlying paginator from this iterator and returns it. The
     * paginator will yield arrays of unmarshalled items, with each yielded
     * array corresponding to a single call to the underlying API. As with the
     * underlying API, pages may contain a variable number of items or no items,
     * in which case an empty array will be yielded.
     *
     * Calling this method will disable further iteration.
     */
    ItemIterator.prototype.pages = function () {
        // Prevent the iterator from being used further and squelch any uncaught
        // promise rejection warnings
        this.lastResolved = Promise.reject(new Error('The underlying paginator has been detached from this iterator.'));
        this.lastResolved.catch(function () { });
        return this.paginator;
    };
    /**
     * @inheritDoc
     */
    ItemIterator.prototype.return = function () {
        // Prevent any further use of this iterator
        this.lastResolved = Promise.reject(new Error('Iteration has been manually interrupted and may not be resumed'));
        this.lastResolved.catch(function () { });
        // Clear the pending queue to free up memory
        this.pending.length = 0;
        return this.paginator.return().then(doneSigil);
    };
    Object.defineProperty(ItemIterator.prototype, "scannedCount", {
        /**
         * The number of items evaluated, before any ScanFilter is applied. A high
         * scannedCount value with few, or no, Count results indicates an
         * inefficient Scan operation. For more information, see Count and
         * ScannedCount in the Amazon DynamoDB Developer Guide.
         */
        get: function () {
            return this.paginator.scannedCount;
        },
        enumerable: true,
        configurable: true
    });
    ItemIterator.prototype.getNext = function () {
        var _this = this;
        if (this.pending.length > 0) {
            this._iteratedCount++;
            return Promise.resolve({
                value: this.pending.shift(),
                done: false
            });
        }
        return this.paginator.next().then(function (_a) {
            var done = _a.done, value = _a.value;
            var _b;
            if (done) {
                return { done: done };
            }
            (_b = _this.pending).push.apply(_b, tslib_1.__spread(value.Items || []));
            return _this.getNext();
        });
    };
    return ItemIterator;
}());
exports.ItemIterator = ItemIterator;
function doneSigil() {
    return { done: true };
}
//# sourceMappingURL=ItemIterator.js.map